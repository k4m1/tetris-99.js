{"ast":null,"code":"import { createTracing } from \"trace_events\";\nconst canvas = document.getElementById('tetris');\nconst context = canvas.getContext('2d');\ncontext.scale(20, 20);\ncontext.fillStyle = '#000';\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.height);\n\nconst collision = (playArea, player) => {\n  const [m, o] = [player.matrix, player.pos];\n\n  for (let y = 0; y < m.length; y++) {\n    for (let x = 0; x < m[y].length; x++) {\n      if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst createMatrix = (width, height) => {\n  const matrix = []; // while height is not 0\n\n  while (height--) {\n    matrix.push(new Array(width).fill(0));\n  }\n\n  return matrix;\n};\n\nconst createTetris = type => {\n  if (type === 'T') {\n    return [[0, 0, 0], [1, 1, 1], [0, 1, 0]];\n  } else if (type === 'O') {\n    return [[2, 2], [2, 2]];\n  } else if (type === 'L') {\n    return [[0, 3, 0], [0, 3, 0], [0, 3, 3]];\n  } else if (type === 'J') {\n    return [[0, 4, 0], [0, 4, 0], [4, 4, 0]];\n  } else if (type === 'I') {\n    return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];\n  } else if (type === 'S') {\n    return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];\n  } else if (type === 'Z') {\n    return [[7, 7, 0], [0, 7, 7], [0, 0, 0]];\n  }\n};\n\nconst draw = () => {\n  context.fillStyle = '#000';\n  context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n  drawMatrix(playArea, {\n    x: 0,\n    y: 0\n  });\n  drawMatrix(player.matrix, player.pos);\n};\n\nconst drawMatrix = (nmatrix, offset) => {\n  matrix.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value != 0) {\n        context.fillStyle = colors[value];\n        context.fillRect(x + offset.x, y + offset.y, 1, 1);\n      }\n    });\n  });\n};\n\nconst merge = (playArea, player) => {\n  player.matrix.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value !== 0) {\n        playArea[y + player.pos.y][x + player.pos.x] = value;\n      }\n    });\n  });\n};\n\nconst playerDrop = () => {\n  player.pos.y++;\n\n  if (collision(playArea, player)) {\n    player.pos.y--;\n    merge(playArea, player);\n    playerReset();\n  }\n\n  dropCounter = 0;\n};\n\nconst playerMove = direction => {\n  player.pos.x += direction;\n\n  if (collision(playArea, player)) {\n    player.pos.x -= direction;\n  }\n};\n\nconst playerReset = () => {\n  const tetrises = \"ILJOTSZ\";\n  player.matrix = createTetris(tetrises[tetrises.length * Math.random() | 0]);\n  player.pos.y = 0;\n  player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n\n  if (collision(playArea, player)) {\n    playArea.forEach(row => row.fill(0));\n  }\n};\n\nconst playerRotation = direction => {\n  let offset = 1;\n  rotate(player.matrix, direction);\n\n  while (collision(playArea, player)) {\n    player.pos.x += offset;\n    offset = -(offset + (offset > 0 ? 1 : -1));\n\n    if (offset > player.matrix[0].length) {\n      rotate(player.matrix, -dir);\n      player.pos.x = pos;\n      return;\n    }\n  }\n};\n\nconst rotate = (matrix, direction) => {\n  for (let y = 0; y < matrix.length; y++) {\n    for (let x = 0; x < y; x++) {\n      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];\n    }\n  }\n\n  if (direction > 0) {\n    matrix.forEach(row => row.reverse());\n  } else {\n    matrix.reverse();\n  }\n};\n\nlet dropCounter = 0;\nlet dropInterval = 1000;\nlet lastTime = 0;\n\nconst update = (time = 0) => {\n  const deltatime = time - lastTime;\n  lastTime = time;\n  dropCounter += deltatime;\n\n  if (dropCounter > dropInterval) {\n    playerDrop();\n  }\n\n  draw();\n  requestAnimationFrame(update);\n};\n\nconst playArea = createMatrix(12, 20);\nconst player = {\n  pos: {\n    x: 5,\n    y: 5\n  },\n  matrix: createTetris('T')\n}; // These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\n\ndocument.addEventListener('keydown', e => {\n  if (e.keyCode === 37) {\n    playerMovement(-1);\n  } else if (e.keyCode === 39) {\n    playerMovement(1);\n  } else if (e.keyCode === 40) {\n    playerDrop();\n  } else if (e.keyCode === 81) {\n    playerRotation(-1);\n  } else if (e.keyCode === 87) {\n    playerRotation(1);\n  }\n});\nconst colors = [null, 'purple', 'yellow', 'blue', 'orange', 'light blue', 'green', 'red'];\nupdate();","map":{"version":3,"sources":["/Users/bebop/Desktop/GitHub Reasources /websocket-tetris/pages/index.js"],"names":["createTracing","canvas","document","getElementById","context","getContext","scale","fillStyle","fillRect","clientWidth","height","collision","playArea","player","m","o","matrix","pos","y","length","x","createMatrix","width","push","Array","fill","createTetris","type","draw","drawMatrix","nmatrix","offset","forEach","row","value","colors","merge","playerDrop","playerReset","dropCounter","playerMove","direction","tetrises","Math","random","playerRotation","rotate","dir","reverse","dropInterval","lastTime","update","time","deltatime","requestAnimationFrame","addEventListener","e","keyCode","playerMovement"],"mappings":"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","sourcesContent":["import { createTracing } from \"trace_events\";\n\nconst canvas = document.getElementById('tetris');\nconst context = canvas.getContext('2d');\n\ncontext.scale(20,20);\n\ncontext.fillStyle = '#000';\ncontext.fillRect(0,0, canvas.clientWidth, canvas.height);\n\n\n\n\nconst collision = (playArea, player) => {\n    const [m, o] = [player.matrix, player.pos];\n    for (let y = 0; y < m.length; y++) {\n        for (let x = 0; x < m[y].length; x++) {\n            if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n                return true\n\n            }\n        }\n    }\n    return false\n}\n\nconst createMatrix = (width, height) => {\n    const matrix = [];\n    // while height is not 0\n    while (height--) {\n        matrix.push(new Array(width).fill(0));\n    }\n    return matrix\n\n}\n\nconst createTetris = type => {\n    if (type === 'T') {\n        return [\n            [0, 0, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ];\n    } else if (type === 'O') {\n        return [\n            [2, 2],\n            [2, 2],\n        ];\n    } else if (type === 'L') {\n        return [\n            [0, 3, 0],\n            [0, 3, 0],\n            [0, 3, 3],\n        ];\n    } else if (type === 'J') {\n        return [\n            [0, 4, 0],\n            [0, 4, 0],\n            [4, 4, 0],\n        ];\n    } else if (type === 'I') {\n        return [\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n        ];\n    } else if (type === 'S') {\n        return [\n            [0, 6, 6],\n            [6, 6, 0],\n            [0, 0, 0],\n        ];\n    } else if (type === 'Z') {\n        return [\n            [7, 7, 0],\n            [0, 7, 7],\n            [0, 0, 0],\n        ];\n    }\n}\n\n\nconst draw = () => {\n    context.fillStyle = '#000';\n    context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n    drawMatrix(playArea, {x: 0, y: 0})\n    drawMatrix(player.matrix, player.pos)\n}\n\nconst drawMatrix = (nmatrix, offset) => {\n    \n    matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value != 0) {\n                context.fillStyle = colors[value];\n                context.fillRect(x + offset.x, y + offset.y, 1, 1);\n            }\n        });\n    });\n}\n\nconst merge = (playArea, player) => {\n    player.matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value !== 0 ) {\n                playArea[y + player.pos.y][x + player.pos.x] = value\n            }\n        })\n    })\n}\n\n\nconst playerDrop = () => {\n    player.pos.y++;\n    if (collision(playArea, player)) {\n        player.pos.y--;\n        merge(playArea, player);\n        playerReset();\n    }\n    dropCounter = 0;\n}\n\nconst playerMove = direction => {\n    player.pos.x += direction;\n    if (collision(playArea, player)) {\n        player.pos.x -= direction;\n    }\n}\n\nconst playerReset = () => {\n    const tetrises = \"ILJOTSZ\";\n    player.matrix= createTetris(tetrises[tetrises.length * Math.random() | 0]);\n    player.pos.y = 0;\n    player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n    if (collision(playArea, player)) {\n        playArea.forEach(row => row.fill(0));\n    }\n}\n\nconst playerRotation = (direction) => {\n    let offset = 1\n    rotate(player.matrix, direction)\n    while (collision(playArea, player)) {\n        player.pos.x += offset;\n        offset = -(offset + (offset > 0 ? 1 : -1));\n        if (offset > player.matrix[0].length) {\n            rotate(player.matrix, -dir);\n            player.pos.x = pos;\n            return;\n        }\n    }\n}\n\n\nconst rotate = (matrix, direction) => {\n    for (let y = 0; y < matrix.length; y++ ) {\n        for (let x = 0; x < y; x++) {\n            [\n                matrix[x][y],\n                matrix[y][x],\n            ] = [\n                matrix[y][x], \n                matrix[x][y],\n            ]\n        }\n    }\n\n    if (direction > 0) {\n        matrix.forEach(row => row.reverse())\n    } else {\n        matrix.reverse();\n    }\n\n}\n\n\nlet dropCounter = 0;\nlet dropInterval = 1000;\n\nlet lastTime = 0\n\nconst update = (time = 0) => {\n    const deltatime = time - lastTime;\n    lastTime = time\n\n    dropCounter += deltatime\n    if (dropCounter > dropInterval) {\n        playerDrop()\n    }\n    draw();\n    requestAnimationFrame(update);\n\n}\n\nconst playArea = createMatrix(12, 20);\n\n\nconst player = {\n    pos: { x: 5, y: 5},\n    matrix: createTetris('T'),\n}\n\n// These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\ndocument.addEventListener('keydown', e => {\n    if (e.keyCode === 37) {\n        playerMovement(-1);\n    } else if (e.keyCode === 39) {\n        playerMovement(1);\n    } else if (e.keyCode === 40) {\n        playerDrop()\n    } else if (e.keyCode === 81) {\n        playerRotation(-1)\n    } else if (e.keyCode === 87) {\n        playerRotation(1)\n    }\n\n})\n\nconst colors = [\nnull,\n'purple',\n'yellow',\n'blue',\n'orange',\n'light blue',\n'green',\n'red'\n]\n\nupdate()\n"]},"metadata":{},"sourceType":"module"}