{"ast":null,"code":"import { createTracing } from \"trace_events\";\nconst canvas = document.getElementById('tetris');\nconst context = canvas.getContext('2d');\ncontext.scale(20, 20);\ncontext.fillStyle = '#000';\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.height);\n\nconst playAreaClear = () => {\n  outer: for (let y = playArea.length - 1; y < 0; --y) {\n    for (let x = 0; x < playArea[y].length; ++x) {\n      if (playArea[y][x] === 0) {\n        continue outer;\n      }\n    }\n\n    const row = playArea.splice(y, 1)[0].fill[0];\n    playArea.unshift(row);\n    ++y;\n  }\n};\n\nconst collision = (playArea, player) => {\n  const [m, o] = [player.matrix, player.pos];\n\n  for (let y = 0; y < m.length; y++) {\n    for (let x = 0; x < m[y].length; x++) {\n      if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst createMatrix = (width, height) => {\n  const matrix = []; // while height is not 0\n\n  while (height--) {\n    matrix.push(new Array(width).fill(0));\n  }\n\n  return matrix;\n};\n\nconst createTetris = type => {\n  if (type === 'T') {\n    return [[0, 0, 0], [1, 1, 1], [0, 1, 0]];\n  } else if (type === 'O') {\n    return [[2, 2], [2, 2]];\n  } else if (type === 'L') {\n    return [[0, 3, 0], [0, 3, 0], [0, 3, 3]];\n  } else if (type === 'J') {\n    return [[0, 4, 0], [0, 4, 0], [4, 4, 0]];\n  } else if (type === 'I') {\n    return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];\n  } else if (type === 'S') {\n    return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];\n  } else if (type === 'Z') {\n    return [[7, 7, 0], [0, 7, 7], [0, 0, 0]];\n  }\n};\n\nconst draw = () => {\n  context.fillStyle = '#000';\n  context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n  drawMatrix(playArea, {\n    x: 0,\n    y: 0\n  });\n  drawMatrix(player.matrix, player.pos);\n};\n\nconst drawMatrix = (nmatrix, offset) => {\n  matrix.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value != 0) {\n        context.fillStyle = colors[value];\n        context.fillRect(x + offset.x, y + offset.y, 1, 1);\n      }\n    });\n  });\n};\n\nconst merge = (playArea, player) => {\n  player.matrix.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value !== 0) {\n        playArea[y + player.pos.y][x + player.pos.x] = value;\n      }\n    });\n  });\n};\n\nconst playerDrop = () => {\n  player.pos.y++;\n\n  if (collision(playArea, player)) {\n    player.pos.y--;\n    merge(playArea, player);\n    playerReset();\n    playAreaClear();\n  }\n\n  dropCounter = 0;\n};\n\nconst playerMove = direction => {\n  player.pos.x += direction;\n\n  if (collision(playArea, player)) {\n    player.pos.x -= direction;\n  }\n};\n\nconst playerReset = () => {\n  const tetrises = \"ILJOTSZ\";\n  player.matrix = createTetris(tetrises[tetrises.length * Math.random() | 0]);\n  player.pos.y = 0;\n  player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n\n  if (collision(playArea, player)) {\n    playArea.forEach(row => row.fill(0));\n  }\n};\n\nconst playerRotation = direction => {\n  let offset = 1;\n  rotate(player.matrix, direction);\n\n  while (collision(playArea, player)) {\n    player.pos.x += offset;\n    offset = -(offset + (offset > 0 ? 1 : -1));\n\n    if (offset > player.matrix[0].length) {\n      rotate(player.matrix, -dir);\n      player.pos.x = pos;\n      return;\n    }\n  }\n};\n\nconst rotate = (matrix, direction) => {\n  for (let y = 0; y < matrix.length; y++) {\n    for (let x = 0; x < y; x++) {\n      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];\n    }\n  }\n\n  if (direction > 0) {\n    matrix.forEach(row => row.reverse());\n  } else {\n    matrix.reverse();\n  }\n};\n\nlet dropCounter = 0;\nlet dropInterval = 1000;\nlet lastTime = 0;\n\nconst update = (time = 0) => {\n  const deltatime = time - lastTime;\n  lastTime = time;\n  dropCounter += deltatime;\n\n  if (dropCounter > dropInterval) {\n    playerDrop();\n  }\n\n  draw();\n  requestAnimationFrame(update);\n};\n\nconst playArea = createMatrix(12, 20);\nconst player = {\n  pos: {\n    x: 5,\n    y: 5\n  },\n  matrix: createTetris('T')\n}; // These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\n\ndocument.addEventListener('keydown', e => {\n  if (e.keyCode === 37) {\n    playerMovement(-1);\n  } else if (e.keyCode === 39) {\n    playerMovement(1);\n  } else if (e.keyCode === 40) {\n    playerDrop();\n  } else if (e.keyCode === 81) {\n    playerRotation(-1);\n  } else if (e.keyCode === 87) {\n    playerRotation(1);\n  }\n});\nconst colors = [null, 'purple', 'yellow', 'blue', 'orange', 'light blue', 'green', 'red'];\nupdate();","map":{"version":3,"sources":["/Users/bebop/Desktop/GitHub Reasources /websocket-tetris/pages/index.js"],"names":["createTracing","canvas","document","getElementById","context","getContext","scale","fillStyle","fillRect","clientWidth","height","playAreaClear","outer","y","playArea","length","x","row","splice","fill","unshift","collision","player","m","o","matrix","pos","createMatrix","width","push","Array","createTetris","type","draw","drawMatrix","nmatrix","offset","forEach","value","colors","merge","playerDrop","playerReset","dropCounter","playerMove","direction","tetrises","Math","random","playerRotation","rotate","dir","reverse","dropInterval","lastTime","update","time","deltatime","requestAnimationFrame","addEventListener","e","keyCode","playerMovement"],"mappings":"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","sourcesContent":["import { createTracing } from \"trace_events\";\n\nconst canvas = document.getElementById('tetris');\nconst context = canvas.getContext('2d');\n\ncontext.scale(20,20);\n\ncontext.fillStyle = '#000';\ncontext.fillRect(0,0, canvas.clientWidth, canvas.height);\n\n\nconst playAreaClear = () => {\n    outer: for (let y = playArea.length -1; y < 0; --y) {\n        for (let x = 0; x < playArea[y].length; ++x) {\n            if (playArea[y][x] === 0) {\n                continue outer;\n            }\n        }\n        const row = playArea.splice(y, 1)[0].fill[0];\n        playArea.unshift(row);\n        ++y;\n    }\n}\n\n\nconst collision = (playArea, player) => {\n    const [m, o] = [player.matrix, player.pos];\n    for (let y = 0; y < m.length; y++) {\n        for (let x = 0; x < m[y].length; x++) {\n            if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n                return true\n\n            }\n        }\n    }\n    return false\n}\n\nconst createMatrix = (width, height) => {\n    const matrix = [];\n    // while height is not 0\n    while (height--) {\n        matrix.push(new Array(width).fill(0));\n    }\n    return matrix\n\n}\n\nconst createTetris = type => {\n    if (type === 'T') {\n        return [\n            [0, 0, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ];\n    } else if (type === 'O') {\n        return [\n            [2, 2],\n            [2, 2],\n        ];\n    } else if (type === 'L') {\n        return [\n            [0, 3, 0],\n            [0, 3, 0],\n            [0, 3, 3],\n        ];\n    } else if (type === 'J') {\n        return [\n            [0, 4, 0],\n            [0, 4, 0],\n            [4, 4, 0],\n        ];\n    } else if (type === 'I') {\n        return [\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n        ];\n    } else if (type === 'S') {\n        return [\n            [0, 6, 6],\n            [6, 6, 0],\n            [0, 0, 0],\n        ];\n    } else if (type === 'Z') {\n        return [\n            [7, 7, 0],\n            [0, 7, 7],\n            [0, 0, 0],\n        ];\n    }\n}\n\n\nconst draw = () => {\n    context.fillStyle = '#000';\n    context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n    drawMatrix(playArea, {x: 0, y: 0})\n    drawMatrix(player.matrix, player.pos)\n}\n\nconst drawMatrix = (nmatrix, offset) => {\n    \n    matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value != 0) {\n                context.fillStyle = colors[value];\n                context.fillRect(x + offset.x, y + offset.y, 1, 1);\n            }\n        });\n    });\n}\n\nconst merge = (playArea, player) => {\n    player.matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value !== 0 ) {\n                playArea[y + player.pos.y][x + player.pos.x] = value\n            }\n        })\n    })\n}\n\n\nconst playerDrop = () => {\n    player.pos.y++;\n    if (collision(playArea, player)) {\n        player.pos.y--;\n        merge(playArea, player);\n        playerReset();\n        playAreaClear();\n    }\n    dropCounter = 0;\n}\n\nconst playerMove = direction => {\n    player.pos.x += direction;\n    if (collision(playArea, player)) {\n        player.pos.x -= direction;\n    }\n}\n\nconst playerReset = () => {\n    const tetrises = \"ILJOTSZ\";\n    player.matrix= createTetris(tetrises[tetrises.length * Math.random() | 0]);\n    player.pos.y = 0;\n    player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n    if (collision(playArea, player)) {\n        playArea.forEach(row => row.fill(0));\n    }\n}\n\nconst playerRotation = (direction) => {\n    let offset = 1\n    rotate(player.matrix, direction)\n    while (collision(playArea, player)) {\n        player.pos.x += offset;\n        offset = -(offset + (offset > 0 ? 1 : -1));\n        if (offset > player.matrix[0].length) {\n            rotate(player.matrix, -dir);\n            player.pos.x = pos;\n            return;\n        }\n    }\n}\n\n\nconst rotate = (matrix, direction) => {\n    for (let y = 0; y < matrix.length; y++ ) {\n        for (let x = 0; x < y; x++) {\n            [\n                matrix[x][y],\n                matrix[y][x],\n            ] = [\n                matrix[y][x], \n                matrix[x][y],\n            ]\n        }\n    }\n\n    if (direction > 0) {\n        matrix.forEach(row => row.reverse())\n    } else {\n        matrix.reverse();\n    }\n\n}\n\n\nlet dropCounter = 0;\nlet dropInterval = 1000;\n\nlet lastTime = 0\n\nconst update = (time = 0) => {\n    const deltatime = time - lastTime;\n    lastTime = time\n\n    dropCounter += deltatime\n    if (dropCounter > dropInterval) {\n        playerDrop()\n    }\n    draw();\n    requestAnimationFrame(update);\n\n}\n\nconst playArea = createMatrix(12, 20);\n\n\nconst player = {\n    pos: { x: 5, y: 5},\n    matrix: createTetris('T'),\n}\n\n// These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\ndocument.addEventListener('keydown', e => {\n    if (e.keyCode === 37) {\n        playerMovement(-1);\n    } else if (e.keyCode === 39) {\n        playerMovement(1);\n    } else if (e.keyCode === 40) {\n        playerDrop()\n    } else if (e.keyCode === 81) {\n        playerRotation(-1)\n    } else if (e.keyCode === 87) {\n        playerRotation(1)\n    }\n\n})\n\nconst colors = [\nnull,\n'purple',\n'yellow',\n'blue',\n'orange',\n'light blue',\n'green',\n'red'\n]\n\nupdate()\n"]},"metadata":{},"sourceType":"module"}