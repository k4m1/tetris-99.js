{"ast":null,"code":"import { createTracing } from \"trace_events\";\nvar canvas = document.getElementById('tetris');\nvar context = canvas.getContext('2d');\ncontext.scale(20, 20);\ncontext.fillStyle = '#000';\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.height);\n\nvar playAreaClear = function playAreaClear() {\n  outer: for (var y = playArea.length - 1; y < 0; --y) {\n    for (var x = 0; x < playArea[y].length; ++x) {\n      if (playArea[y][x] === 0) {\n        continue outer;\n      }\n    }\n\n    var row = playArea.splice(y, 1)[0].fill[0];\n    playArea.unshift(row);\n    ++y;\n  }\n};\n\nvar collision = function collision(playArea, player) {\n  var _ref = [player.matrix, player.pos],\n      m = _ref[0],\n      o = _ref[1];\n\n  for (var y = 0; y < m.length; y++) {\n    for (var x = 0; x < m[y].length; x++) {\n      if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nvar createMatrix = function createMatrix(width, height) {\n  var matrix = []; // while height is not 0\n\n  while (height--) {\n    matrix.push(new Array(width).fill(0));\n  }\n\n  return matrix;\n};\n\nvar createTetris = function createTetris(type) {\n  if (type === 'T') {\n    return [[0, 0, 0], [1, 1, 1], [0, 1, 0]];\n  } else if (type === 'O') {\n    return [[2, 2], [2, 2]];\n  } else if (type === 'L') {\n    return [[0, 3, 0], [0, 3, 0], [0, 3, 3]];\n  } else if (type === 'J') {\n    return [[0, 4, 0], [0, 4, 0], [4, 4, 0]];\n  } else if (type === 'I') {\n    return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];\n  } else if (type === 'S') {\n    return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];\n  } else if (type === 'Z') {\n    return [[7, 7, 0], [0, 7, 7], [0, 0, 0]];\n  }\n};\n\nvar draw = function draw() {\n  context.fillStyle = '#000';\n  context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n  drawMatrix(playArea, {\n    x: 0,\n    y: 0\n  });\n  drawMatrix(player.matrix, player.pos);\n};\n\nvar drawMatrix = function drawMatrix(nmatrix, offset) {\n  matrix.forEach(function (row, y) {\n    row.forEach(function (value, x) {\n      if (value != 0) {\n        context.fillStyle = colors[value];\n        context.fillRect(x + offset.x, y + offset.y, 1, 1);\n      }\n    });\n  });\n};\n\nvar merge = function merge(playArea, player) {\n  player.matrix.forEach(function (row, y) {\n    row.forEach(function (value, x) {\n      if (value !== 0) {\n        playArea[y + player.pos.y][x + player.pos.x] = value;\n      }\n    });\n  });\n};\n\nvar playerDrop = function playerDrop() {\n  player.pos.y++;\n\n  if (collision(playArea, player)) {\n    player.pos.y--;\n    merge(playArea, player);\n    playerReset();\n    playAreaClear();\n  }\n\n  dropCounter = 0;\n};\n\nvar playerMove = function playerMove(direction) {\n  player.pos.x += direction;\n\n  if (collision(playArea, player)) {\n    player.pos.x -= direction;\n  }\n};\n\nvar playerReset = function playerReset() {\n  var tetrises = \"ILJOTSZ\";\n  player.matrix = createTetris(tetrises[tetrises.length * Math.random() | 0]);\n  player.pos.y = 0;\n  player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n\n  if (collision(playArea, player)) {\n    playArea.forEach(function (row) {\n      return row.fill(0);\n    });\n  }\n};\n\nvar playerRotation = function playerRotation(direction) {\n  var offset = 1;\n  rotate(player.matrix, direction);\n\n  while (collision(playArea, player)) {\n    player.pos.x += offset;\n    offset = -(offset + (offset > 0 ? 1 : -1));\n\n    if (offset > player.matrix[0].length) {\n      rotate(player.matrix, -dir);\n      player.pos.x = pos;\n      return;\n    }\n  }\n};\n\nvar rotate = function rotate(matrix, direction) {\n  for (var y = 0; y < matrix.length; y++) {\n    for (var x = 0; x < y; x++) {\n      var _ref2 = [matrix[y][x], matrix[x][y]];\n      matrix[x][y] = _ref2[0];\n      matrix[y][x] = _ref2[1];\n    }\n  }\n\n  if (direction > 0) {\n    matrix.forEach(function (row) {\n      return row.reverse();\n    });\n  } else {\n    matrix.reverse();\n  }\n};\n\nvar dropCounter = 0;\nvar dropInterval = 1000;\nvar lastTime = 0;\n\nvar update = function update() {\n  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var deltatime = time - lastTime;\n  lastTime = time;\n  dropCounter += deltatime;\n\n  if (dropCounter > dropInterval) {\n    playerDrop();\n  }\n\n  draw();\n  requestAnimationFrame(update);\n};\n\nvar playArea = createMatrix(12, 20);\nvar player = {\n  pos: {\n    x: 5,\n    y: 5\n  },\n  matrix: createTetris('T')\n}; // These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\n\ndocument.addEventListener('keydown', function (e) {\n  if (e.keyCode === 37) {\n    playerMovement(-1);\n  } else if (e.keyCode === 39) {\n    playerMovement(1);\n  } else if (e.keyCode === 40) {\n    playerDrop();\n  } else if (e.keyCode === 81) {\n    playerRotation(-1);\n  } else if (e.keyCode === 87) {\n    playerRotation(1);\n  }\n});\nvar colors = [null, 'purple', 'yellow', 'blue', 'orange', 'light blue', 'green', 'red'];\nupdate();","map":{"version":3,"sources":["/Users/bebop/Desktop/GitHub Reasources /websocket-tetris/pages/index.js"],"names":["createTracing","canvas","document","getElementById","context","getContext","scale","fillStyle","fillRect","clientWidth","height","playAreaClear","outer","y","playArea","length","x","row","splice","fill","unshift","collision","player","matrix","pos","m","o","createMatrix","width","push","Array","createTetris","type","draw","drawMatrix","nmatrix","offset","forEach","value","colors","merge","playerDrop","playerReset","dropCounter","playerMove","direction","tetrises","Math","random","playerRotation","rotate","dir","reverse","dropInterval","lastTime","update","time","deltatime","requestAnimationFrame","addEventListener","e","keyCode","playerMovement"],"mappings":"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","sourcesContent":["import { createTracing } from \"trace_events\";\n\nconst canvas = document.getElementById('tetris');\nconst context = canvas.getContext('2d');\n\ncontext.scale(20,20);\n\ncontext.fillStyle = '#000';\ncontext.fillRect(0,0, canvas.clientWidth, canvas.height);\n\n\nconst playAreaClear = () => {\n    outer: for (let y = playArea.length -1; y < 0; --y) {\n        for (let x = 0; x < playArea[y].length; ++x) {\n            if (playArea[y][x] === 0) {\n                continue outer;\n            }\n        }\n        const row = playArea.splice(y, 1)[0].fill[0];\n        playArea.unshift(row);\n        ++y;\n    }\n}\n\n\nconst collision = (playArea, player) => {\n    const [m, o] = [player.matrix, player.pos];\n    for (let y = 0; y < m.length; y++) {\n        for (let x = 0; x < m[y].length; x++) {\n            if (m[y][x] !== 0 && (playArea[y + o.y] && playArea[y + o.y][x + o.x]) !== 0) {\n                return true\n\n            }\n        }\n    }\n    return false\n}\n\nconst createMatrix = (width, height) => {\n    const matrix = [];\n    // while height is not 0\n    while (height--) {\n        matrix.push(new Array(width).fill(0));\n    }\n    return matrix\n\n}\n\nconst createTetris = type => {\n    if (type === 'T') {\n        return [\n            [0, 0, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ];\n    } else if (type === 'O') {\n        return [\n            [2, 2],\n            [2, 2],\n        ];\n    } else if (type === 'L') {\n        return [\n            [0, 3, 0],\n            [0, 3, 0],\n            [0, 3, 3],\n        ];\n    } else if (type === 'J') {\n        return [\n            [0, 4, 0],\n            [0, 4, 0],\n            [4, 4, 0],\n        ];\n    } else if (type === 'I') {\n        return [\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n            [0, 5, 0, 0],\n        ];\n    } else if (type === 'S') {\n        return [\n            [0, 6, 6],\n            [6, 6, 0],\n            [0, 0, 0],\n        ];\n    } else if (type === 'Z') {\n        return [\n            [7, 7, 0],\n            [0, 7, 7],\n            [0, 0, 0],\n        ];\n    }\n}\n\n\nconst draw = () => {\n    context.fillStyle = '#000';\n    context.fillRect(0, 0, canvas.clientWidth, canvas.height);\n    drawMatrix(playArea, {x: 0, y: 0})\n    drawMatrix(player.matrix, player.pos)\n}\n\nconst drawMatrix = (nmatrix, offset) => {\n    \n    matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value != 0) {\n                context.fillStyle = colors[value];\n                context.fillRect(x + offset.x, y + offset.y, 1, 1);\n            }\n        });\n    });\n}\n\nconst merge = (playArea, player) => {\n    player.matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n            if (value !== 0 ) {\n                playArea[y + player.pos.y][x + player.pos.x] = value\n            }\n        })\n    })\n}\n\n\nconst playerDrop = () => {\n    player.pos.y++;\n    if (collision(playArea, player)) {\n        player.pos.y--;\n        merge(playArea, player);\n        playerReset();\n        playAreaClear();\n    }\n    dropCounter = 0;\n}\n\nconst playerMove = direction => {\n    player.pos.x += direction;\n    if (collision(playArea, player)) {\n        player.pos.x -= direction;\n    }\n}\n\nconst playerReset = () => {\n    const tetrises = \"ILJOTSZ\";\n    player.matrix= createTetris(tetrises[tetrises.length * Math.random() | 0]);\n    player.pos.y = 0;\n    player.pos.x = (playArea[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);\n    if (collision(playArea, player)) {\n        playArea.forEach(row => row.fill(0));\n    }\n}\n\nconst playerRotation = (direction) => {\n    let offset = 1\n    rotate(player.matrix, direction)\n    while (collision(playArea, player)) {\n        player.pos.x += offset;\n        offset = -(offset + (offset > 0 ? 1 : -1));\n        if (offset > player.matrix[0].length) {\n            rotate(player.matrix, -dir);\n            player.pos.x = pos;\n            return;\n        }\n    }\n}\n\n\nconst rotate = (matrix, direction) => {\n    for (let y = 0; y < matrix.length; y++ ) {\n        for (let x = 0; x < y; x++) {\n            [\n                matrix[x][y],\n                matrix[y][x],\n            ] = [\n                matrix[y][x], \n                matrix[x][y],\n            ]\n        }\n    }\n\n    if (direction > 0) {\n        matrix.forEach(row => row.reverse())\n    } else {\n        matrix.reverse();\n    }\n\n}\n\n\nlet dropCounter = 0;\nlet dropInterval = 1000;\n\nlet lastTime = 0\n\nconst update = (time = 0) => {\n    const deltatime = time - lastTime;\n    lastTime = time\n\n    dropCounter += deltatime\n    if (dropCounter > dropInterval) {\n        playerDrop()\n    }\n    draw();\n    requestAnimationFrame(update);\n\n}\n\nconst playArea = createMatrix(12, 20);\n\n\nconst player = {\n    pos: { x: 5, y: 5},\n    matrix: createTetris('T'),\n}\n\n// These event listners will move the player left or right by incremnting the x plane\n// the 'down' control sets our 'dropCounter' to zero which tirggers a 'move' down one position\ndocument.addEventListener('keydown', e => {\n    if (e.keyCode === 37) {\n        playerMovement(-1);\n    } else if (e.keyCode === 39) {\n        playerMovement(1);\n    } else if (e.keyCode === 40) {\n        playerDrop()\n    } else if (e.keyCode === 81) {\n        playerRotation(-1)\n    } else if (e.keyCode === 87) {\n        playerRotation(1)\n    }\n\n})\n\nconst colors = [\nnull,\n'purple',\n'yellow',\n'blue',\n'orange',\n'light blue',\n'green',\n'red'\n]\n\nupdate()\n"]},"metadata":{},"sourceType":"module"}